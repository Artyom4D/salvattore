// Generated by CoffeeScript 1.6.1

/*
Salvattore by @rnmp and @ppold
http://github.com/bandd/salvattore
*/


(function() {
  var addElement, addElements, add_columns, filter_children, forEach, get_content, get_direct_children, grids, media_query_change, media_rule_has_columns_selector, nodeList2Array, proto, recreate_columns, remove_columns, scan_media_queries, slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  nodeList2Array = function(nodes) {
    var arr, i, node, _i, _len;
    arr = [];
    for (i = _i = 0, _len = nodes.length; _i < _len; i = ++_i) {
      node = nodes[i];
      arr[i] = node;
    }
    return arr;
  };

  if (typeof document !== 'undefined' && !('classList' in document.createElement('a'))) {
    (function(view) {
      'use strict';
      var ClassList, DOMEx, arrIndexOf, checkTokenAndGetIndex, classListGetter, classListProp, classListPropDesc, elemCtrProto, objCtr, protoProp, strTrim;
      if (!('HTMLElement' in view) && !('Element' in view)) {
        return;
      }
      classListProp = 'classList';
      protoProp = 'prototype';
      elemCtrProto = (view.HTMLElement || view.Element)[protoProp];
      objCtr = Object;
      strTrim = String[protoProp].trim || function() {
        return this.replace(/^\s+|\s+$/g, '');
      };
      arrIndexOf = Array[protoProp].indexOf || function(item) {
        var i, len;
        i = 0;
        len = this.length;
        while (i < len) {
          if (i in this && this[i] === item) {
            return i;
          }
          i++;
        }
        return -1;
      };
      DOMEx = function(type, message) {
        this.name = type;
        this.code = DOMException[type];
        return this.message = message;
      };
      DOMEx[protoProp] = Error[protoProp];
      checkTokenAndGetIndex = function(classList, token) {
        if (token === '') {
          throw new DOMEx('SYNTAX_ERR', 'An invalid or illegal string was specified');
        }
        if (/\s/.test(token)) {
          throw new DOMEx('INVALID_CHARACTER_ERR', 'String contains an invalid character');
        }
        return arrIndexOf.call(classList, token);
      };
      ClassList = (function(_super) {

        __extends(ClassList, _super);

        function ClassList(elem) {
          var classes, cls, trimmedClasses, _i, _len;
          trimmedClasses = elem.className ? strTrim.call(elem.className) : void 0;
          classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [];
          for (_i = 0, _len = classes.length; _i < _len; _i++) {
            cls = classes[_i];
            this.push(cls);
          }
          this._updateClassName = function() {
            return elem.className = this.toString();
          };
        }

        ClassList.prototype.item = function(i) {
          return this[i] || null;
        };

        ClassList.prototype.contains = function(token) {
          token += '';
          return checkTokenAndGetIndex(this, token) !== -1;
        };

        ClassList.prototype.add = function() {
          var i, l, token, tokens, updated;
          tokens = arguments;
          i = 0;
          l = tokens.length;
          token;
          updated = false;
          while (i < l) {
            token = tokens[i] + '';
            if (checkTokenAndGetIndex(this, token) === -1) {
              this.push(token);
              updated = true;
            }
            i++;
          }
          if (updated) {
            return this._updateClassName();
          }
        };

        ClassList.prototype.remove = function() {
          var i, index, l, token, tokens, updated;
          tokens = arguments;
          i = 0;
          l = tokens.length;
          token;
          updated = false;
          while (i < l) {
            token = tokens[i] + '';
            index = checkTokenAndGetIndex(this, token);
            if (index !== -1) {
              this.splice(index, 1);
              updated = true;
            }
            i++;
          }
          if (updated) {
            return this._updateClassName();
          }
        };

        ClassList.prototype.toggle = function(token, forse) {
          var method, result;
          token += '';
          result = this.contains(token);
          if (result) {
            method = forse !== true && 'remove';
          } else {
            method = forse !== false && 'add';
          }
          if (method) {
            this[method](token);
          }
          return result;
        };

        ClassList.prototype.toString = function() {
          return this.join(' ');
        };

        return ClassList;

      })(Array);
      classListGetter = function() {
        return new ClassList(this);
      };
      if (objCtr.defineProperty) {
        classListPropDesc = {
          get: classListGetter,
          enumerable: true,
          configurable: true
        };
        try {
          return objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
        } catch (ex) {
          if (ex.number === -0x7FF5EC54) {
            classListPropDesc.enumerable = false;
            return objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);
          }
        }
      } else if (objCtr[protoProp].__defineGetter__) {
        return elemCtrProto.__defineGetter__(classListProp, classListGetter);
      }
    })(self);
  }

  if (!Array.prototype.forEach) {
    Array.prototype.forEach = function(callback, thisArg) {
      var O, T, k, kValue, len, _results;
      if (!this) {
        throw new TypeError('this is null or not defined');
      }
      O = Object(this);
      len = O.length >>> 0;
      if ({}.toString.call(callback) !== '[object Function]') {
        throw new TypeError(callback + ' is not a function');
      }
      if (thisArg) {
        T = thisArg;
      }
      k = 0;
      _results = [];
      while (k < len) {
        if (Object.prototype.hasOwnProperty.call(O, k)) {
          kValue = O[k];
          callback.call(T, kValue, k, O);
        }
        _results.push(k++);
      }
      return _results;
    };
  }

  if (!window.getComputedStyle) {
    window.getComputedStyle = function(el, pseudo) {
      this.el = el;
      this.getPropertyValue = function(prop) {
        if (prop === 'float') {
          prop = 'styleFloat';
        }
        return el.currentStyle[prop] || null;
      };
      return this;
    };
  }

  get_content = function(element) {
    var className, computedStyle, content, matchResult, numberOfColumns;
    computedStyle = window.getComputedStyle(element, ':before');
    content = (computedStyle.getPropertyValue('content') || computedStyle.getPropertyValue('-ms-content')).slice(1, -1);
    matchResult = content.match(/^\s*(\d+)(?:\s?\.(.+))?\s*$/);
    if (matchResult) {
      numberOfColumns = matchResult[1];
      className = matchResult[2] || 'column';
    } else {
      matchResult = content.match(/^\s*\.(.+)\s+(\d+)\s*$/);
      className = matchResult[1];
      numberOfColumns = matchResult[2];
    }
    return {
      numberOfColumns: numberOfColumns,
      className: className
    };
  };

  get_direct_children = function(element) {
    var directChildren, m, node, nodes;
    directChildren = element.children;
    if (directChildren.length !== 1) {
      return directChildren;
    }
    directChildren = [];
    nodes = element.childNodes;
    m = nodes.length;
    while (--m !== -1) {
      node = nodes[m];
      if (node.nodeType === 1) {
        directChildren.push(node);
      }
    }
    return directChildren;
  };

  filter_children = function(elements, a, b) {
    var element, filtered_children, i, j, _i, _len;
    filtered_children = new Array(Math.ceil(elements.length / a));
    j = 0;
    for (i = _i = 0, _len = elements.length; _i < _len; i = ++_i) {
      element = elements[i];
      if (i % a === b) {
        filtered_children[j++] = element;
      }
    }
    return filtered_children;
  };

  add_columns = function(element) {
    var columnClass, columnElements, columns, dataColumnsContent, elements, i;
    dataColumnsContent = get_content(element);
    columns = dataColumnsContent.numberOfColumns;
    columnClass = dataColumnsContent.className;
    elements = new Array(+columns);
    i = columns;
    while (i-- !== 0) {
      try {
        columnElements = element.querySelectorAll('[data-columns] > *:nth-child(' + columns + 'n-' + i + ')');
      } catch (error) {
        columnElements = filter_children(get_direct_children(element), columns, i);
      }
      elements.push(columnElements);
    }
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
    forEach.call(elements, function(columnElements) {
      var column;
      column = document.createElement('div');
      column.classList.add(columnClass);
      forEach.call(columnElements, function(element) {
        return column.appendChild(element);
      });
      return element.appendChild(column);
    });
    return element.setAttribute('data-columns', columns);
  };

  remove_columns = function(element) {
    var children, ncol, orderedChildren;
    children = element.children;
    ncol = children.length;
    orderedChildren = new Array(children[0].children.length * element.dataset.columns);
    forEach.call(children, function(child, i) {
      return forEach.call(child.children, function(child, j) {
        return orderedChildren[j * ncol + i] = child;
      });
    });
    orderedChildren.forEach(function(child) {
      if (child != null) {
        return element.appendChild(child);
      }
    });
    while (ncol-- !== 0) {
      element.removeChild(children[0]);
    }
  };

  media_rule_has_columns_selector = function(rules) {
    var i;
    i = rules.length;
    while (i-- !== 0) {
      if (rules[i].selectorText.match(/\[data-columns\]::before$/)) {
        return true;
      }
    }
    return false;
  };

  recreate_columns = function(grid) {
    remove_columns(grid);
    return add_columns(grid);
  };

  media_query_change = function(mql) {
    if (mql.matches) {
      return grids.forEach(recreate_columns);
    }
  };

  scan_media_queries = function() {
    var mediaQueries, stylesheets;
    if (!window.matchMedia) {
      return;
    }
    stylesheets = slice.call(document.querySelectorAll('style[type="text/css"]')).concat(slice.call(document.querySelectorAll('link[rel="stylesheet"]')));
    mediaQueries = [];
    forEach.call(stylesheets, function(stylesheet) {
      return forEach.call(stylesheet.sheet.cssRules, function(rule) {
        if (rule.media && media_rule_has_columns_selector(rule.cssRules)) {
          return mediaQueries.push(window.matchMedia(rule.media.mediaText));
        }
      });
    });
    return mediaQueries.forEach(function(mql) {
      return mql.addListener(media_query_change);
    });
  };

  addElements = function(grid, elements) {
    return elements.forEach(addElement);
  };

  addElement = function(grid, element) {
    var child, children, currentRowCount, highestRowCount, i, m, _i, _len;
    children = grid.children;
    m = children.length;
    for (i = _i = 0, _len = children.length; _i < _len; i = ++_i) {
      child = children[i];
      currentRowCount = child.children.length;
      if (i !== 0 && highestRowCount > currentRowCount) {
        break;
      } else if ((i + 1) === m) {
        child = children[0];
        break;
      }
      highestRowCount = currentRowCount;
    }
    return child.appendChild(element);
  };

  proto = Array.prototype;

  forEach = proto.forEach;

  slice = proto.slice;

  grids = nodeList2Array(document.querySelectorAll('[data-columns]'));

  grids.forEach(add_columns);

  scan_media_queries();

  window['salvattore'] = {
    addElement: addElement,
    addElements: addElements
  };

}).call(this);
